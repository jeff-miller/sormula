/* sormula - Simple object relational mapping
 * Copyright (C) 2011-2012 Jeff Miller
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.sormula.operation;

import java.lang.reflect.Field;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.sormula.Table;
import org.sormula.annotation.cascade.Cascade;
import org.sormula.annotation.cascade.OneToManyCascade;
import org.sormula.annotation.cascade.OneToOneCascade;
import org.sormula.annotation.cascade.SaveCascade;
import org.sormula.annotation.cascade.SaveCascadeAnnotationReader;
import org.sormula.cache.CacheException;
import org.sormula.log.ClassLogger;
import org.sormula.operation.cascade.CascadeOperation;
import org.sormula.operation.cascade.SaveCascadeOperation;
import org.sormula.reflect.RowField;


/**
 * SQL update or insert operation for row of type R. Rows are updated if they exist
 * in the database or inserted if they are new rows. Cascades are performed based upon
 * {@link Cascade#saves()}, {@link OneToManyCascade#saves()}, or {@link OneToOneCascade#saves()}.
 * <p>
 * Inserts and updates are performed by class members of type {@link InsertOperation} 
 * and {@link UpdateOperation}. Since most of the work is delegated to {@link InsertOperation} 
 * and {@link UpdateOperation}, not all methods of base class {@link ModifyOperation} are
 * used. All of the methods in SaveOperation may be safely overridden but some subclass methods
 * may not be used. 
 *  
 * @param <R> class type which contains members for columns of a row in a table
 * 
 * @since 1.1
 * @author Jeff Miller
 */
public class SaveOperation<R> extends ModifyOperation<R>
{
	private static ClassLogger log = new ClassLogger();
    InsertOperation<R> insertOperation;
    UpdateOperation<R> updateOperation;
    boolean invokeSuper;
    int[] modifyCounts;
    
    
    /**
     * Constructs to update by primary key or insert if update fails.
     * 
     * @param table update/insert to this table
     * @throws OperationException if error
     */
    public SaveOperation(Table<R> table) throws OperationException
    {
        this(table, true, "primaryKey");
    }
    
    
    /**
     * Constructs to update by primary key or insert if update fails.
     * <p>
     * This constructor is equivalent to SaveOperation(Table, boolean, "primaryKey"). Use
     * this constructor when you want identity columns to be inserted without using
     * autogenerated keys (use false for identity parameter). 
     * 
     * @param table update/insert to this table
     * @param identity true to insert using autogenerated keys for identity columns;
     * false to insert identity columns as without generating key  
     * @throws OperationException if error
     * @since 4.1
     */
    public SaveOperation(Table<R> table, boolean identity) throws OperationException
    {
        this(table, identity, "primaryKey");
    }
    
    
    /** 
     * Constructs to update by where condition or insert if update fails. Inserts use
     * autogenerated keys for identity columns. This constructor is equivalent 
     * to SaveOperation(Table, true, String).
     * 
     * @param table update/insert to this table
     * @param whereConditionName name of where condition to use for update ("primaryKey" to update
     * by primary key; empty string to update all rows in table)
     * @throws OperationException if error
     */
    public SaveOperation(Table<R> table, String whereConditionName) throws OperationException
    {
        this(table, true, whereConditionName);
    }
    
    
    /** 
     * Constructs to update by where condition or insert if update fails.
     * <p>
     * Use this constructor when you want identity columns to be inserted without using
     * autogenerated keys (use false for identity parameter). 
     * 
     * @param table update/insert to this table
     * @param identity true to insert using autogenerated keys for identity columns;
     * false to insert identity columns as without generating key  
     * @param whereConditionName name of where condition to use for update ("primaryKey" to update
     * by primary key; empty string to update all rows in table)
     * @throws OperationException if error
     * @since 4.1
     */
    public SaveOperation(Table<R> table, boolean identity, String whereConditionName) throws OperationException
    {
        super(table);
        
        insertOperation = new InsertOperation<R>(table, identity)
		{
			@Override
			protected List<CascadeOperation<R, ?>> prepareCascades(Field field) throws OperationException 
			{
				// delegate to SaveOperation so that cascades are save operations instead of insert operations
				return SaveOperation.this.prepareCascades(field);
			}
			
			@Override
			protected void preExecute(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.preExecute(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.preExecute(row);
			}

			@Override
			protected void postExecute(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.postExecute(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.postExecute(row);
			}

			@Override
			protected void preExecuteCascade(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.preExecuteCascade(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.preExecuteCascade(row);			
			}

			@Override
			protected void postExecuteCascade(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.postExecuteCascade(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.postExecuteCascade(row);
			}
		};
        
		updateOperation = new UpdateOperation<R>(table)
		{
			@Override
			protected List<CascadeOperation<R, ?>> prepareCascades(Field field) throws OperationException 
			{
				// delegate to SaveOperation so that cascades are save operations instead of update operations
				return SaveOperation.this.prepareCascades(field);
			}

			@Override
			protected void preExecute(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.preExecute(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.preExecute(row);
			}

			@Override
			protected void postExecute(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.postExecute(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.postExecute(row);
			}

			@Override
			protected void preExecuteCascade(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.preExecuteCascade(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.preExecuteCascade(row);
			}

			@Override
			protected void postExecuteCascade(R row) throws OperationException 
			{
				// delegate to SaveOperation so that it may be overridden by subclass of SaveOperation
				invokeSuper = false;
				SaveOperation.this.postExecuteCascade(row); // if subclass overrides then invokeSuper remains false
				if (invokeSuper) super.postExecuteCascade(row);
			}
		};
        updateOperation.setWhere(whereConditionName);
    }


    @Override
    public void close() throws OperationException
    {
        insertOperation.close();
        updateOperation.close();
    }

    
    /**
     * For each row saved, gets modify counts either from {@link UpdateOperation#getModifyCounts()}
     * if row was updated or from {@link InsertOperation#getModifyCounts()} if row was inserted.
     * 
     * @return modify counts of all rows processed; each element is associated with one row processed
     * @since 4.1
     */
    @Override
    public int[] getModifyCounts()
    {
        // based upon return of insertOperation and updateOperation
        return modifyCounts;
    }


    /**
     * Sets batch state for internal insert and update operations.
     * 
     * @param batch true for batch save 
     * @since 3.0
     */
    @Override
    public void setBatch(boolean batch)
    {
        super.setBatch(batch);
        insertOperation.setBatch(batch);
        updateOperation.setBatch(batch);
    }


    /**
     * Sets cached enabled state for internal insert and update operations.
     * 
     * @param cached true to enable cache; false to turn off caching
     * @since 3.0
     */
    @Override
    public void setCached(boolean cached)
    {
        super.setCached(cached);
        insertOperation.setCached(cached);
        updateOperation.setCached(cached);
    }


    /**
     * Sets cascade state for internal insert and update operations.
     * 
     * @param cascade true to allow cascades to occur; false for no cascading
     * @since 3.0
     */
    @Override
    public void setCascade(boolean cascade)
    {
        super.setCascade(cascade);
        insertOperation.setCascade(cascade);
        updateOperation.setCascade(cascade);
    }


    /**
     * Saves a row. Set parameters, executes, closes. 
     * Alias for {@link #modify(Object)}.
     * 
     * @param row row to use for parameters
     * @return {@link #getRowsAffected()}
     * @throws OperationException if error
     * @since 1.4
     */
    public int save(R row) throws OperationException
    {
        return super.modify(row);
    }


    /**
     * Saves all rows in collection. Set parameters, executes, closes. 
     * Alias for {@link #modifyAll(Collection)}.
     * 
     * @param rows collection of rows to use as parameters 
     * @return {@link #getRowsAffected()}
     * @throws OperationException if error
     * @since 1.4
     */
    public int saveAll(Collection<R> rows) throws OperationException
    {
        return super.modifyAll(rows);
    }


    /**
     * Saves rows based upon parameters. Set parameters, executes, closes. 
     * Alias for {@link #modify(Object...)}.
     * 
     * @param parameters operation parameters as objects (see {@link #setParameters(Object...)})
     * @return count of rows affected
     * @throws OperationException if error
     * @since 1.4
     */
    public int save(Object... parameters) throws OperationException
    {
        return super.modify(parameters);
    }


    /**
     * Executes by updating all row(s) using {@link UpdateOperation}. For all rows
     * that are not updated, uses {@link InsertOperation} to insert them.
     * 
     * @throws OperationException if error
     * @throws BatchException for batch operations if EXECUTE_FAILED is returned
     * @throws BatchException for batch operations if SUCCESS_NO_INFO is returned and cascading is needed
     * @throws BatchException for batch operations if SUCCESS_NO_INFO is returned for update
     */
    @Override
    public void execute() throws OperationException
    {
        int allRowsAffected = 0; 
        
        try
        {
            if (rows != null)
            {
                // operation parameters from rows
                
                /* TODO needed?
                for (R row: rows)
                {
                    if (isCached())
                    {
                        // must do this so that UncommittedSave is created in cache
                        // if not, then UncommittedUpdate will erroneously be created in cache by updateOperation.execute() below 
                        if (log.isDebugEnabled()) log.debug("save cache " + table.getRowClass());
                        notifyCacheModify(row); 
                    }
                }
                */
                
                // attempt to update all rows, for those not updated then insert
                updateOperation.setRows(rows);
                updateOperation.execute();
                allRowsAffected = updateOperation.getRowsAffected();
                modifyCounts = updateOperation.getModifyCounts();
                
                // build list of rows to insert - those with modify count of 0
                List<R> insertRows = new ArrayList<>(rows.size());
                int modifyRowIndex = 0;
                for (R row: rows)
                {
                    int count = modifyCounts[modifyRowIndex];
                    if (count == 0)
                    {
                        // row was not updated, add to insert list
                        insertRows.add(row); 
                    }
                    else if (count == Statement.SUCCESS_NO_INFO)
                    {
                        throw new BatchException("SUCCESS_NO_INFO returned for executeBatch() update; cannot determine if insert is needed");
                    }
                    
                    ++modifyRowIndex;
                }
                
                // insert rows that were not updated
                insertOperation.setRows(insertRows);
                insertOperation.execute();
                allRowsAffected += insertOperation.getRowsAffected();
                int[] insertModifyCounts = insertOperation.getModifyCounts();
                
                // for inserted rows, set modifyCounts
                int insertRowIndex = 0;
                for (modifyRowIndex = 0; modifyRowIndex < modifyCounts.length; ++modifyRowIndex)
                {
                    if (modifyCounts[modifyRowIndex] == 0)
                    {
                        // modifyRowIndex was not updated, set insert count
                        modifyCounts[modifyRowIndex] = insertModifyCounts[insertRowIndex++];
                    }
                    
                    ++modifyRowIndex;
                }
            }
            else if (getParameters() != null)
            {
                // operation parameters from objects (not typical)
                
                // try update first
                updateOperation.setParameters(getParameters());
                updateOperation.execute();

                if (updateOperation.getRowsAffected() == 1)
                {
                    // update succeeded
                    allRowsAffected = 1;
                    modifyCounts = updateOperation.getModifyCounts();
                }
                else
                {
                    // update did not succeed, assume record does not exist
                    insertOperation.setParameters(getParameters());
                    insertOperation.execute();
                    allRowsAffected += insertOperation.getRowsAffected();
                    modifyCounts = insertOperation.getModifyCounts();
                }
            }
            else
            {
                // no rows
                modifyCounts = new int[0];
            }
            
            if (log.isDebugEnabled())
            {
                for (int i = 0; i < modifyCounts.length; ++i) log.debug("modifyCounts[" + i + "]=" + modifyCounts[i]);
            }
        }
        catch (Exception e)
        {
            throw new OperationException("execute() error", e);
        }
        
        setRowsAffected(allRowsAffected);
    }


    /**
     * Creates save cascade operations based upon the save annotations for field.
     *
     * @param field annotation is for this field of row class R
     * @return list of save cascade operations; empty list for none
     * @throws OperationException if error
     * @since 1.9.3 and 2.3.3
     */
    @Override
    protected List<CascadeOperation<R, ?>> prepareCascades(Field field) throws OperationException
    {
        List<CascadeOperation<R, ?>> co = null;
        SaveCascadeAnnotationReader scar = new SaveCascadeAnnotationReader(field);
        SaveCascade[] saveCascades = scar.getSaveCascades();
        
        if (saveCascades.length > 0 && isRequiredCascade(scar.getName()))
        {
            // at least one save cascade
            if (log.isDebugEnabled()) log.debug("prepareCascades() for " + field.getName());
            @SuppressWarnings("unchecked") // target field type is not known at compile time
            Table<R> targetTable = (Table<R>)getTargetTable(scar.getTargetClass());
            RowField<R, ?> targetField = createRowField(targetTable, field);
            co = new ArrayList<CascadeOperation<R, ?>>(saveCascades.length);
            
            // for each cascade operation
            for (SaveCascade c: saveCascades)
            {
                if (log.isDebugEnabled()) log.debug("prepare cascade " + c.operation());
                @SuppressWarnings("unchecked") // target field type is not known at compile time
                CascadeOperation<R, ?> operation = new SaveCascadeOperation(this, targetField, targetTable, c);
                if (c.setForeignKeyValues()) operation.setForeignKeyFieldNames(scar.getForeignKeyValueFields());
                if (c.setForeignKeyReference()) operation.setForeignKeyReferenceFieldName(scar.getForeignKeyReferenceField());
                
                operation.prepare();
                co.add(operation);
            }
        }
        else
        {
            // no cascades
            co = Collections.emptyList();
        }
        
        return co;
    }
	
    
    /**
     * {@inheritDoc}
     */
	@Override
	protected void preExecute(R row) throws OperationException 
	{
		// indicate to invoke InsertOperation/UpdateOperation equivalent method
		invokeSuper = true;
	}

	
    /**
     * {@inheritDoc}
     */
	@Override
	protected void postExecute(R row) throws OperationException 
	{
		// indicate to invoke InsertOperation/UpdateOperation equivalent method
		invokeSuper = true;
	}

	
    /**
     * {@inheritDoc}
     */
	@Override
	protected void preExecuteCascade(R row) throws OperationException 
	{
		// indicate to invoke InsertOperation/UpdateOperation equivalent method
		invokeSuper = true;
	}


    /**
     * {@inheritDoc}
     */
	@Override
	protected void postExecuteCascade(R row) throws OperationException 
	{
		// indicate to invoke InsertOperation/UpdateOperation equivalent method
		invokeSuper = true;
	}


    /**
     * {@inheritDoc}
     */
    @Override
    protected boolean notifyCacheModify(R row) throws OperationException
    {
        try
        {
            return getTable().getCache().save(row);
        }
        catch (CacheException e)
        {
            throw new OperationException("cache error", e);
        }
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public void notifyCacheModified(R row) throws OperationException
    {
        try
        {
            getTable().getCache().saved(row);
        }
        catch (CacheException e)
        {
            throw new OperationException("cache error", e);
        }
    }
}
